# アーキテクチャ設計アドバイス まとめ

### 1. アプリケーションの起動シーケンスとEntryPointの役割

アプリケーションの起動処理は、関心事の分離を徹底するため、以下の役割分担で行います。

*   **EntryPoint (起動役):**
    *   **原則:** アプリケーションの起動（DIコンテナの初期化完了）をトリガーに、最初のビジネスロジックを呼び出すことだけを責務とする、**専用の起動クラス**（例: `ApplicationInitializer`）を`EntryPoint`として登録します。
    *   **実装:** このクラスは `IAsyncStartable` 等を実装し、コンストラクタで統括役の`UseCase`（例: `GameInitializeUseCase`）をインジェクトします。`StartAsync`メソッド内では、その`UseCase`のメソッドを呼び出すだけです。
    *   **責務:** `EntryPoint`は、VContainerのライフサイクルと、アプリケーションのビジネスロジック層を繋ぐ「接着剤」の役割に徹し、それ以外のロジックを持ちません。

*   **UseCase (司令塔):**
    *   **原則:** `GameInitializeUseCase`のような統括役のUseCaseが、実際の初期化処理（チーム生成、データロード等）を担当する個別の専門UseCaseを呼び出します。
    *   **責務:** ビジネスロジックの実行手順（どの処理をどの順番で、または並列で実行するか）を定義します。UnityやVContainerのライフサイクルからは完全に独立しています。

*   **Presenter (UI担当):**
    *   **原則:** `Presenter`は`EntryPoint`である必要はありません。`UseCase`からのイベント（`R3`や`MessagePipe`経由）を購読し、ビジネスロジックの完了を検知して初めてUIの更新処理を開始します。

**メリット:** この構成により、ビジネスロジックがUnityのライフサイクルから完全に分離され、テスト容易性が最大化されます。また、各クラスが単一の責務に集中するため、コードの見通しが良く、拡張性の高いアプリケーション構造を維持できます。

---

### 2. 各レイヤーのロジック責務分担

判断基準は「**そのロジックが、何についての判断（関心事）を行っているか？**」です。

| レイヤー | `if`/`for`文 (フロー制御) | 計算ロジック |
| :--- | :--- | :--- |
| **Presenter** | **UIの状態を決定するため**<br>例：HPが少なければUIを赤くする | **表示用のデータ整形のため**<br>例：数値を「¥1,000」形式の文字列にする |
| **UseCase** | **ビジネスルールの判定や手順のため**<br>例：レベルが足りなければ処理を中断する | **ビジネス上の数値を算出するため**<br>例：税込み価格やダメージ量を計算する |
| **Entity** | **自身の状態を保護するため**<br>例：HPがマイナスにならないようにする | **自身の状態から導出できる値を算出するため**<br>例：HPが0より大きいか(IsAlive)を返す |

**メリット:** `UseCase`と`Entity`がUnityのUIから完全に独立し、単体テストが容易になります。各クラスの責務が明確になり、コードの再利用性とメンテナンス性が向上します。

---

### 3. レイヤー間の通信：「状態」にはR3、「イベント」にはMessagePipe

`UseCase`から`Presenter`への通知など、疎結合な通信には目的によってツールを使い分けます。

*   **R3 (`ReactiveProperty<T>`)**: **状態(State)の伝搬**に最適
    *   **用途:** HP、スコア、音量設定など、UIに**常に現在の値を表示**したい場合。
    *   **理由:** 購読すると即座に**現在値**が通知され、その後の変更も受け取れるため、UIの表示ロジックをシンプルに記述できます。

*   **MessagePipe**: **イベント(Event)の通知**に最適
    *   **用途:** 「プレイヤーがジャンプした」「敵を倒した」「エラーが発生した」など、**一過性の出来事**を通知したい場合。
    *   **理由:** 「Fire and Forget」でメッセージをブロードキャストする仕組みであり、状態を保持しないため、瞬間的な出来事の通知に適しています。

**メリット:** それぞれのツールの特性を活かすことで、意図が明確で無駄のない通信を実装できます。

---

### 4. `Handler`レイヤーの再定義

*   **機能別Handlerの廃止:** `AudioHandler`や`PlayerClubHandler`のように、特定の機能ロジックを持つ`Handler`は、その責務を新しい**機能別`Presenter`に吸収・統合**させ、廃止します。
*   **汎用Handlerの活用:** `ButtonHandler`のように、特定の機能に依存せず「ボタンの連打防止」のような**汎用的な共通処理**を提供する`Handler`は、便利なツールとして残し、各`Presenter`から利用します。

**メリット:** `Presenter`という責務名に役割を集約することで、アーキテクチャ全体がシンプルになり、命名の混乱を防ぎます。

---

これらの原則は、一見すると厳格に思えるかもしれませんが、遵守することでコードの各部分が疎結合で独立し、結果として非常に変更に強く、テストしやすいアプリケーションに繋がります。今後の開発の指針として、ぜひご活用ください。
